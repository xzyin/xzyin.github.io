---
layout: post
title: YouTube DNN论文精读
description: "读YouTube DNN的一些思考"
modified: 2020-10-01
tags: [Deep Learning, Seq2Seq]
categories: [算法]
image:
  path: /images/algorthim/youtube_dnn_model/1.PNG
  feature: /algorthim/youtube_dnn_model/1.PNG
  credit: x1
  creditlink: https://deeplearn.org/arxiv/69226/a-comparative-study-on-hierarchical-navigable-small-world-graphs
---
目录

* TOC 
{:toc}

# Abstract

YouTube DNN代表了现存的最大规模和最复杂的个性化推荐系统。在这篇文章中，
我们从一个很高的角度描述了整个系统的结构并且集中介绍了深度学习给推荐系统带来的巨大提升。
这篇文章根据拆分成为采用传统的检索的两段式：
* 首先我们介绍了一个候选集生成模型。

* 然后我们介绍了一个不同的排序模型。

在论文中我们还提供设计、迭代和维护一个面对用户的大规模推荐系统的经验和见解。

# 1.Introduction

YouTube DNN是全世界最大的视频创作、分享、发现平台。
YouTube推荐系统负责帮助亿万级用户从日益增长的视频语料中发现个性化的内容。
在这篇文章中，我们主要介绍深度学习对YouTube DNN推荐带来的巨大影响。
在图1中给出了YouTube DNN的主页情况。

在YouTube DNN的视频推荐中主要存在以下三个问题:

* Scale: 许多已经存在的算法在小数据集上能够跑通，
但是在我们的数据规模上无法有效运行。
高度专业化的分布式学习算法和高效的服务系统
对于处理YouTube庞大的用户群和语料库至关重要。

* Freshness: YouTube有一个大规模的动态语料库，每分秒钟有几个小时的视频上传。
推荐系统应该在尽可能少的用户行为下能够对新上传的内容作出较快的响应。
系统能够通过exploration和exploitation来平衡新内容和已经验证过的内容。

* Noise: 由于用户行为的不可观测性和用户行为的稀疏性使得用户行为本身就难以被理解。
我们很难能够获得用户满意度的真实表达，更多的是对有噪声的隐式反馈信号进行建模。
此外，与内容相关联的元数据在没有良好定义实体的情况下很难被结构化。
我们的算法需要对我们这种特殊的数据集具有鲁棒性。

在谷歌的产品矩阵中，YouTube经历一个根本性的范式转变，
使得深度学习成为解决所有问题的通用手段。
我们在谷歌大脑上构建了我们的模型，最近开源成了TensorFlow。
TensorFlow提供了一个合适的框架来使用大规模数据实验各种深度神经网络结构。
我们的模型学习了大约在上亿的样本上学习了大约一亿的参数。

与矩阵分解方法的大量研究相反，
在推荐系统中使用深度神经网络的方法相关的工作较少。
深度神经网络在论文[17]中用于推荐新闻，在论文[8]中用户推荐论文，
在[20]中用于review评分。在论文[22]中协同过滤被公式化为深度神经网络，
在论文[18]中被公式化为自动编码器。Elkahky等人使用深度神经网络学习
对跨领域的用户进行建模。在内容推荐领域里面，
Burges等人使用深度网络做音乐推荐。

我们的论文组织结构如下:

在第二节中我们对推荐系统做了一个简要地概述，
第三节中我们描述了推荐系统中候选集生成的具体细节，
包括如何训练以及推荐系统服务的部署。
在第四小节中介绍了排序模型的细节，包括如何使用logistic
regression对播放时长进行建模(而不是点击率)。
实验结果将显示隐藏层深度在这种情况下对实验结果有帮助。
最后，在第5小节中，我们给出了我们的结论和经验教训。

# 2.System Overview

在图2中，我们给出了整个系统的结构，整个系统由两个神经网络组成:
一个生成候选集另外一个对用户召回结果进行排序。

候选集生成网络以YouTube的用户行为历史作为输入，
从大规模的视频语料中挑选一个小的子集(百级别的)。
这些候选集基本上跟用户的具有较高的相关性。
候选集生成网络通过协同过滤提供广泛的个性化，
用户之间的相似性用粗糙的特征来表示，例如观看视频的id，
查询的历史以及人口统计信息。

给出的一个最好的几个视频的候选列表中，
需要一个精细的表示来区分候选视频之间相对的重要性。
排序网络通过使用丰富的用户特征和行为特征设计一个目标函数
来完成这项任务。最后，通过得分对这些视频进行排序，
得分最高的视频将被提供给这些用户。

这两个过程的方法能够使得我们从大规模语料库中给用户推荐视频，
同时保证那一小部分视频呈现给用户的时候具有较高的准确性。
此外这种方法能够混合其他来源的候选项，如我们在早期的工作中描述的那样。

在开发的过程中，我们广泛地使用离线的评估指标例如(precision, recall, ranking loss等等)
来指导模型在我们的系统上的迭代，然而最后决定模型是否有效，我们取决于线上的AB实验。

在线上实验当中，我们可以测量点击率、观看时长和许多其他衡量用户参与度的指标的细微变化。
这是非常重要的，因为实时的AB测试并总是和离线结果相关。


# 3.Candidate Generation

在候选集生成阶段，需要从大规模的候选集中筛选出成百上千的与用户相关的视频。
在文章[23]中描述了一个基于矩阵分解的推荐方法。
我们早期的迭代模拟这种因子分解的方式采用浅层的神经网络对用户行为做嵌入。

从这个角度上来看，我们的方法可以看成是一种因式分解技术的通用推广。

## 3.1 Recommendation as classification

我们可以将候选集生成的过程看成是一个极端的多分类问题。
那么这个时候问题就转化成了一个特殊的分类准确性问题。
一个用户$U$, 上下文为$V$的用户分类准确性的问题。

$$P(w_t=i|U,C) = \frac{e^{v_iu}}{\sum_{j \in V}e^{v_ju}}$$

其中$u\in R^N$表示用户和场景对的高维embedding，$v_j \in R^N$
表示每个候选的视频。在这种情况下，embedding只是将稀疏的实体转化为了$R^N$中的稠密向量。

深度神经网络的任务是根据用户的历史和上下文来学习用户的嵌入，
使得使用softmax分类器来区分视频是有用的。虽然在YouTube DNN
中存在显式反馈的机制，但是我们仍然使用用户的隐式播放来训练模型。
当用户看完了一个视频，当成是一个正样本。
我们做这样选择的原因是采用隐式反馈具有更大的数据量级来完成显式
反馈稀疏的情况之下的深度推荐。

* **高效的多分类问题**

为了高效地训练具有成百万分类的模型，
我们依赖一个技术从back-ground分布中采样负样本，
然后通过重要性采样校正这个数据。对于每一个样本，
需要对正样本和负样本计算最小化的交叉熵损失。
在真实的训练中，我们采样了几千个负样本，
那么对应整个候选集来看相比于传统的softmax做了100倍以上的加速。
另外的可供选择的加速方法是采用分层的softmax，但是在softmax
中我们无法达到相当的准确度。在遍历分层softmax的时候，
遍历每个节点的时候通常涉及到区分通常不相关的分类集合，
这增加了分类的难度，从而降低了分类的性能。

在serving阶段，我们需要计算最可能的N个分类，
来挑选出最可能的top N个视频展现给用户。
在数十毫秒的严格服务延时下对成百万规模的物品进行评分
需要一个次线性的近似得分计算方案。
YouTube以前的系统依赖于哈希并且在文章[24]中提供了一个相似度计算的方法。
由于在服务阶段我们只需要一个相对的排序，
不需要在来自softmax输出层的校准似然性，
评分问题可以简化为内积空间中的近邻检索问题。
在论文[12]中给出了一个通用的向量检索库。
我们AB测试的结果对线上使用的近邻检索方法并不是很敏感。

## 3.2 Model Architecture

受到CBOW模型的鼓舞，我们在一个固定的词汇表中学习到每一个视频的embedding然后
喂入到一个前向的神经网络。
用户的观影历史被描述成为一个变长的由稀疏视频id组成的变长序列，
这些视频vid通过嵌入映射成一个稠密的向量表示。
神经网络需要等长稠密向量输入，在这我们采用简单的对embedding求平均的方式。
求平均的方式是几种(sum, component-wise max, 等等)策略里面效果最好的。
重要的是这些向量通过正常的反向传播进行梯度的更新。
所有的特征首先在第一层做一个拼接，然后紧跟着使用几个带ReLU激活函数的全连接层。
图3中给出了包含非视频观看的YouTube DNN的模型结构。

##3.3 Heterogeneous Signals

使用深度神经网络作为一个一般化的矩阵分解方法有一个重要的优点，
任意的连续的和类别特征都可以很容易地加入到模型当中去。
用户的搜索历史采用和用户的播放历史相同的嵌入方式。
每一个查询都被标记成unigrams和bigrams并且每一个embedding都被嵌入。
在进行平均之后，一个用户查询的embedding表示用户的稠密搜索历史的总结。
人口统计特征对于提供优先级次序来说非常重要，这样对于新用户就能够进行合理的推荐。
用户的地理位置和设备信息被嵌入和concat到特征表示当中去。
简单的一些二进制特征和连续特征例如用户性别、登录状态和年龄在网络中直接
被归一化[0,1]之间的真实值。

* **Example Age Feature**

在YouTube上每秒有很多个小时的视频上传。推荐这些新鲜的视频对于YouTube
这个推荐产品而言是十分重要的。我们观察到用户用户更喜欢新的内容，
尽管是以牺牲相关性为代价。此外，除了推荐用户感兴趣的新视频这个直接目的之外，
还有一个次要的目的就是引导和传播内容信息。

机器学习系统通常对于过去建立了一个隐含的偏差。
因为机器学习系统通过学习过去的样本来训练模型。
视频的热度分布是非常不稳定的，但是我们的推荐器
在训练语料上的多项式分布将反应几个星期的训练窗口中的平均观看可能性。
为了纠正这种情况，我们将训练样本的上传时间作为训练当中的一个特征输入。
在serving的阶段这个特征会被设置为0(或者轻微的负数)来反应模型在训练窗口
的最末端进行预测。

图4展示了这种方法在任意选择的视频上的效果，在图中分别给出了BaseLine Model,
With Example Age以及Empirical Distribution三个的分布。

其中Empirical Distribution表示给出的随机某个视频热度的经验分布，
With Example Age表示使用了Example Age属性之后输入不同Example对这个类别概率的预测情况。
BaseLine模型表示不适用BaseLine的情况，
因此使用BaseLine Model只能得到训练窗口下的平均类别概率。

根据图4中的结果，我们发现在使用了Example Age之后我们能够明显的预测视频的热度分布。

## 3.4 Label and Context Selection

需要强调的一个点是推荐通常涉及到解决一个代理问题，
并且将这个结果转到特定的场景下。在推荐领域里面一个经典的假设是这个样子的:
准确的得分预测会带来高效地电影推荐。

我们代理学习问题的选择对线上的A/B测试性能的影响非常重要但是离线评估的时候非常困难。
训练的样本来自YouTube的所有观看(及时这些embeeded在其他站点上)，
而不仅仅是在我们的推荐产品当中，否则新的内容将很难出现，
推荐系统将更多地偏向于利用。如果用户通过推荐之外的其他渠道发现了我们的视频，
我们希望能够通过协同过滤的方式快速递推荐给其他用户。

提升评估指标的另外一个方式就是给用户生成固定长度的训练样本，
这使得我们的用户在损失函数中拥有同等的权重。
这种方法防止了高度活跃的用户对损失的影响比较高。

值得注意的是，我们需要非常小心地从分类器中预留出信息，
以防止模型利用站点的结构过渡拟合了代理问题。
我们来考虑这么一个例子:用户刚刚发布了"泰勒·斯威夫特"的搜索查询。
由于我们的问题是预测下一个观看的视频，
给定该信息推荐系统将预测的最可能观看的视频是那些出现在"泰勒·斯威夫特"的相应搜索结果页面上的视频。
毫无疑问，复制用户最后搜索页面的结果作为主页的推荐表现很差。
通过丢弃序列信息并通过无序的令牌包来表示查询结果，
分类器不再需要直接指导原始的标签来源信息。

视频的自然消费模式，通常会导致非常不对等的共同观看概率。
情节系列通常是按照顺序观看的，
用户如果发现某个流派中比较小众的艺术家通常是从流行的艺术家开始的。
因此，我们发现预测用户的下一个观看视频比随机预测留下出的视频性能要好。
许多协同过滤系统通过保持一个随机项目并且从用户历史中的其他项目预测
这个留出项来隐含地选择标签和上下文。这种方式泄露了未来的信息，
并且忽略了推荐中的过去和未来的非对称消费模式。

相比之下，我们通过随机地选择一个观看的视频来回溯用户的观影历史，
并且只输入用户在观看视频之前的动作。

## 3.5 Experiments with Features and Depth

根据图6中的结果，添加特征和神经网络的深度明显地提高了模型的精度。
在实验中，我们采用了1百万的词汇表和1百万的查询token进行实验，
并且嵌入到256维的浮点向量。在用户行为的选取中，
最大选用了最近的50个观影观影历史和50个检索的token。
在softmax层输出一个相同长度为1百万维度的视频分类输出一个256维的多项分布，
(这个可以看成是独立的输出向量)。模型在YouTube所有的用户数据上进行多轮的迭代，
直到模型发生收敛。网络结构遵循一种常见的“塔”型结构，其中网络的底部最宽，
每个连续的隐藏层将单元数量减半。网络结构遵循常见的塔型结构，
最顶层实际上是一个高效的线性因子分解方案，执行了一个和之前的系统类似的操作。
随着网络的宽度和深度不断增加，直到对增量的效益减少，收敛变得十分困难为止。

* Depth 0: A linear layer simply transforms the concatenation
layer to match the softmax dimension of 256

* Depth 1: 256 ReLU

* Depth 2: 512 ReLU -> 256 ReLU

* Depth 3: 1024 ReLU -> 512 ReLU -> 256 ReLU

* Depth 4: 2048 ReLU -> 1024 ReLU -> 512 ReLU -> 256 ReLU

# 4. RANKING

排序阶段的主要作用是采用用户感兴趣的数据来校准特定用户界面的候选集排序。
例如，用户通常有比较高的可能性观看某个给定的视频，但是在主页的缩略图场景下，
用户对这个视频的点击并不是很强烈。在排序阶段，
我们可以使用更多描述用户与视频关系的特征。
因为这个时候只有少量的视频需要被打分而不是候选集生成阶段百万量级的视频被打分。
排序对于集合分数不可以直接比较的不同候选集源也至关重要。

我们使用和候选集生成阶段相同的网络结构使用LR对每个视频给予单独的得分。
然后这个视频列表通过排序打分并且返回给用户。
我们最终的排序目标是根据线上A/B测试的结果来调整的，
但是基本上是一个关于每个视频预期观看时间的简单函数。
通过点击率进行排序通常会促进用户点击那些欺骗性(标题党和封面党)的视频，
但是观看时间更能捕捉到用户的参与度。

## 4.1 Feature Representation

我们的特征和传统的分类特征和连续特征有比较大的区分。
我们使用的分类特征基数差异很大，有些是二进制的(例如，用户是否登录)
而另外一些是有数百万个可能的值(例如，用户的最后一个查询结果。)
这些特征根据他们贡献了多个值还是一个制分为多阶特征和一阶特征。
一个很明显的一阶特征就是这个视频是否被点击，
而对应的多阶特征就是用户最后观看的 $N$ 个视频ID。
我们还根据特征是否描述了物品的属性或者用户属性和场景属性来进行区分。
查询特征需要在每次请求的时候都计算一次，并且需要针对每个物品计算物品得分。

* **Feature Engineering**

一般来看我们在我们的排序模型里使用上百个的特征，
这些特征大致地分为分类特征和连续特征。
虽然深度学习有望减轻手工特征工程的负担，
但是原始数据的性质并不容易直接输入到前馈神经网络当中去。

我们仍然需要做大量工程转化来讲用户和视频数据转化成有用的特征。
这个问题的主要困难在于如何表示一个时间序列，
并且如何表示这些行为和被评分视频的关系。

我们观察到那些最重要的特征信号就是描述了用户之前与这个item有关交互的其他相似信号。
和他们在广告排序当中的经验相类似。例如考虑用户光影历史里面的类别，
这个用户过去观看了多少和这个视频相同的类别。上一次用户观看这个类别的时间。
这些描述用户在相关项目上的连续特征是非常强大的，
因为这些特征可以很好地在不同的项目之间进行归纳。
同样的我们发现从候选集将特征传播到排序阶段是非常重要的。
例如:例如哪些召回源召回了这个候选集，对应的召回源对着个视频给了多少打分。

描述过去观看了的视频频率的特征在推荐系统引入变动的时候也是至关重要的
(连续的请求不同返回相同的结果)。如果一个用户最近被推荐了某个视频，
但是没有被观看，那么这个模型自然会在下一次加载页面的时候降低这种推荐现象。
如何使用最新的印象和观影历史本身是一个很大的工程，这已经超出了本文的讨论范围。
但是这对于产品响应来说至关重要。

* **Embedding Categorical Features**

与候选集生成阶段相似，对于稀疏特征我们将这些特征映射到一个稠密的向量表示当中。
在ID空间(也就是词汇表中)每一个ID学习到一个对应维度的向量，
向量的维度随着特征维数的增加而增加大概是维数值的对数成比例。
这些查找表是在训练前一次性传入数据的简单查找表。
基数非常大的ID空间(例如，视频的ID或者查询标识)会按照频次排序，
然后对整个表示空间截取前面top N个标识。至于超出词汇表的部分，
embedding都设置成为0。与候选集生成网络相同，
多阶特征在被送入到神经网络当中之前通过加权求平均处理。

重要的是，同一个ID空间中的分类特征也共享相同的embedding。
例如：一个单独的在全局视频ID嵌入可以在许多特征中被使用。
(用户观看、最后一次观看的视频ID等等。)
尽管共享了embedding，但是每个特征都是单独fed到网络当中去的，
因此神经网络可以单独地学习到每个特征的专门表示。
共享嵌入对于提高泛化能力，加快训练速度和减低内存使用都非常重要。
对于排序和召回模型而言绝大多数参数都在这些具有较高基数的嵌入向量当中，
例如：一百万的ID嵌入到一个32维的空间向量当中的参数是一个
有2048个神经元的全连接层参数的7倍。

* **Normalizing Continuous Features**

众所周知神经网络对数据的缩放和分布十分敏感，
而其他的方法对于特征的缩放是不变的，
例如决策树相关的算法。
我们发现对于连续特征适当地做一些归一化对于模型的收敛来说是至关重要的。
在排序模型中，我们将原本具有连续分布$f$的特征 $x$转化为
$\widetilde{x} = \int_{-\infty}^{x} df$ 在开始训练之前，
通过对特征进行预处理并采用欧冠线性插值近似地计算每个特征值对应的积分。

除了在模型中输入$\widetilde{x}$的值之外，
我们还使用了$\widetilde{x}^2$和$\sqrt{\widetilde{x}}$，
作为输入使得网络具有更强的表征能力能够建立这个关于这个特征次线性和亚线性的函数。

## 4.2 Modeling Expected Watch Time

在排序阶段，我们的模型预测的不是正例(视频曝光并且被点击)
和负例(视频曝光但是没有被点击)。在排序阶段，
正例用用户观看的时间长短来表示。为了预测可能的播放时长，
我们使用加权求平均的回归方法。如图7所示，
模型使用交叉熵作为损失函数。但是正向的曝光通过播放时长进行加权。
负向的曝光使用单位权重。这样的话通过逻辑回归得到的odd结果是一个
$\frac{\sum T_i}{N - k}$，其中N是训练的样本个数，
K是正样本曝光，其中$T_i$是第$i$个曝光的播放时长。
假设正样例曝光很小(在我们的case中是true)，近似等于 $E\[T\](1+P)$。
其中 $E\[T\]$ 表示预期的播放时长，其中 $P$ 表示点击率的概率。
因此如果当点击概率非常小的时候，乘积的结果接近播放时长。
在推断过程中，我们使用指数函数
$e^x$ 做最终的激活函数来生成这些odds,来逼近预估的播放时长。

## 4.3 Experiments with Hidden Layers

表1展示了我们在流出数据上，使用不同隐藏层结构得到结果。
在对应的每一个配置下给出的值("weight, per-user loss")
被视为吧所有的正样本(点击了的视频)和负样本(没有点击的视频)
给用户曝光展示在一个页面里面。
我们首先通过我们的模型对两种曝光的物品进行打分。
如果负样本比正样本拿到了更高的得分，
我们就认为正样本预期的观看时间被预测错误。
Weight, per-user loss是所有预测错误的视频的总体播放时长作为分子，
所有曝光视频的播放时长作为分母。
结果表明增加隐藏层的宽度和深度会改善召回的结果。
最后权衡了推断的CPU耗时，采用了1024->512->256的ReLU作为模型结构，
保持最好的结果，同时使得我们的CPU耗时保持在预算内。

在1024->512->256的网络结构里面，
我们尝试只用归一化的特征而不用他们的平方的时候，增加了0.2%的损失。
在相同的参数配置下，我们还训练了一个正负样本具有相同权重的模型，
这个比使用播放时长加权的损失提升了4.1%。

# 5 CONCLUSIONS

# 6 ACKNOWLEDGMENTS

<div align="center">
<image src="/images/algorthim/l1_l2/regular-2.png"/>
</div>

<div align="center">
图1&nbsp;&nbsp;&nbsp;&nbsp;模型训练中的不同状态
</div>